'''spsFreqProgVME Hardware Test Python module

Automatically generated by Topple 0.0.1
'''


__author__ = 'Miguel Ojeda'
__copyright__ = 'Copyright 2015, CERN BE'
__credits__ = ['Miguel Ojeda']
__license__ = 'Unknown'
__maintainer__ = 'Miguel Ojeda'
__email__ = 'mos@cern.ch'


import ctypes
import platform
import struct


class libvmebus(object):
    '''Minimal libvmebus Python binding (with only our needed bits)
    '''

    cpu = 'L865' if platform.machine() == 'i686' else 'L866'
    lib = ctypes.CDLL('/acc/local/%s/drv/vmebus/pyvmelib/libvmebus.so' % cpu)
    vme_map = lib.vme_map
    vme_map.restype = ctypes.c_void_p

    VME_A24_USER_DATA_SCT = 0x39
    VME_A32_USER_DATA_SCT = 0x09
    VME_D16 = 16
    VME_D32 = 32

    class vme_mapping(ctypes.Structure):
        _fields_ = [
	        ('window_num', ctypes.c_int),
	        ('*kernel_va', ctypes.c_void_p),
	        ('user_va', ctypes.c_void_p),
	        ('fd', ctypes.c_int),
	        ('window_enabled', ctypes.c_int),
	        ('data_width', ctypes.c_int),
	        ('am', ctypes.c_int),
	        ('read_prefetch_enabled', ctypes.c_int),
	        ('read_prefetch_size', ctypes.c_int),
	        ('v2esst_mode', ctypes.c_int),
	        ('bcast_select', ctypes.c_int),
	        ('pci_addru', ctypes.c_uint),
	        ('pci_addrl', ctypes.c_uint),
	        ('sizeu', ctypes.c_uint),
	        ('sizel', ctypes.c_uint),
	        ('vme_addru', ctypes.c_uint),
	        ('vme_addrl', ctypes.c_uint),
        ]


def interpret(value, ctype, swapped, fromHardware):
    '''Interpret raw input value as an signed/unsigned integer (according
    to the specified type) and possibly swapped as well (endianess change).
    Same for the other way (fromHardware == False): convert a Python integer to
    the proper raw value for VME.
    '''

    unsignedFormatBySize = {
        1: 'B',
        2: 'H',
        4: 'L',
        8: 'Q',
    }

    size = ctypes.sizeof(ctype)

    signed = ctype in (
        ctypes.c_byte,
        ctypes.c_short,
        ctypes.c_int,
        ctypes.c_long,
        ctypes.c_longlong,
    )

    inputByteOrder = '<'
    outputByteOrder = '<'
    inputFormat = unsignedFormatBySize[size]
    outputFormat = unsignedFormatBySize[size]

    if swapped:
        outputByteOrder = '>'
    if signed:
        if fromHardware:
            outputFormat = outputFormat.lower()
        else:
            inputFormat = inputFormat.lower()
    if ctype == ctypes.c_float:
        if fromHardware:
            outputFormat = 'f'
        else:
            inputFormat = 'f'

    return struct.unpack(outputByteOrder + outputFormat, struct.pack(inputByteOrder + inputFormat, value))[0]


class VMEMapping(object):
    '''Minimal Python class to map the VME bus, based on pyvmelib/libvmebus
    '''

    _typeBySize = {
        1: ctypes.c_ubyte,
        2: ctypes.c_ushort,
        4: ctypes.c_uint,
        8: ctypes.c_ulonglong,
    }

    def __init__(self, addressModifier, dataWidth, baseAddress, size):
        self.dataWidth = dataWidth

        self.mapping = libvmebus.vme_mapping()
        self.mapping.am                    = addressModifier
        self.mapping.data_width            = dataWidth
        self.mapping.vme_addru             = 0
        self.mapping.vme_addrl             = baseAddress
        self.mapping.sizeu                 = 0
        self.mapping.sizel                 = size
        self.mapping.read_prefetch_enabled = 0
        self.mapping.bcast_select          = 0
        self.mapping.window_num            = 0

        self.virtualAddress = libvmebus.vme_map(ctypes.byref(self.mapping), 1)
        if self.virtualAddress is None:
            raise Exception('Error while mapping VME window')


    def pointer(self, offset, ctype):
        '''Returns an unsigned pointer to the specified offset
        '''

        return ctypes.cast(self.virtualAddress + offset, ctypes.POINTER(self._typeBySize[ctypes.sizeof(ctype)]))


    def readList(self, offset, ctype, n):
        '''Reads a list of values at the specified offset
        '''

        address = self.pointer(offset, ctype)
        return [interpret(address[i], ctype, True, True) for i in range(n)]


    def writeList(self, offset, ctype, values):
        '''Writes a list of values at the specified offset
        '''

        # TODO: check values
        address = self.pointer(offset, ctype)
        for i in range(len(values)):
            address[i] = interpret(values[i], ctype, True, False)


    def read(self, offset, ctype):
        '''Reads a single register at the specified offset
        '''

        return self.readList(offset, ctype, 1)[0]


    def write(self, offset, ctype, value):
        '''Writes a single register at the specified offset
        '''

        self.writeList(offset, ctype, [value])


    def read_u8(self, offset):
        return self.read(offset, ctypes.c_ubyte)
    def read_u16(self, offset):
        return self.read(offset, ctypes.c_ushort)
    def read_u32(self, offset):
        return self.read(offset, ctypes.c_uint)
    def read_u64(self, offset):
        return self.read(offset, ctypes.c_ulonglong)


    def read_s8(self, offset):
        return self.read(offset, ctypes.c_byte)
    def read_s16(self, offset):
        return self.read(offset, ctypes.c_short)
    def read_s32(self, offset):
        return self.read(offset, ctypes.c_int)
    def read_s64(self, offset):
        return self.read(offset, ctypes.c_longlong)


    def write_u8(self, offset, value):
        self.write(offset, ctypes.c_ubyte, value)
    def write_u16(self, offset, value):
        self.write(offset, ctypes.c_ushort, value)
    def write_u32(self, offset, value):
        self.write(offset, ctypes.c_uint, value)
    def write_u64(self, offset, value):
        self.write(offset, ctypes.c_ulonglong, value)


    def write_s8(self, offset, value):
        self.write(offset, ctypes.c_byte, value)
    def write_s16(self, offset, value):
        self.write(offset, ctypes.c_short, value)
    def write_s32(self, offset, value):
        self.write(offset, ctypes.c_int, value)
    def write_s64(self, offset, value):
        self.write(offset, ctypes.c_longlong, value)

    def read_float(self, offset):
        return self.read(offset, ctypes.c_float)
    def write_float(self, offset, value):
        self.write(offset, ctypes.c_float, value)


class Mode(object):
    '''VME modes for RF crates
    '''

    pass

class ModeA24D16(Mode):
    addressModifier = libvmebus.VME_A24_USER_DATA_SCT
    dataWidth = libvmebus.VME_D16

class ModeA32D32(Mode):
    addressModifier = libvmebus.VME_A32_USER_DATA_SCT
    dataWidth = libvmebus.VME_D32


defaultSize = 0x50000
defaultMode = ModeA24D16


def getModulesTransferRef():
    '''Get a dictionary of matching devices in the transfer.ref.

    The key of the map is the logical unit number (lun).

    TODO: parse the rest of the columns (e.g. second address window) as well
    '''

    moduleType = 'RF_SPS_FPVME'
    modules = {}
    with open('/etc/transfer.ref', 'rb') as fd:
        for line in fd.readlines():
            if '#+#' in line and moduleType in line:
                tokens = line.strip().split()

                if tokens[3] != 'VME':
                    raise Exception('Non-VME module found (should not happen?)')

                logicalUnitNumber = int(tokens[6])
                if logicalUnitNumber in modules:
                    raise Exception('Several matching modules with the same logical unit number (should not happen?)')

                dataPortSize = tokens[9]
                if not dataPortSize.startswith('DP'):
                    raise Exception('Unrecognized data port size')

                modules[logicalUnitNumber] = {
                    'logicalUnitNumber': logicalUnitNumber,
                    'addressModifier': tokens[8],
                    'dataWidth': int(dataPortSize[2:]),
                    'baseAddress': int(tokens[10], 16),
                    'size': int(tokens[11], 16),
                    'slot': int(tokens[19]) - 6,
                }

    return modules


class Module(object):
    '''Generated VME module abstraction
    '''

    @classmethod
    def slot(Class, slot_, size = defaultSize, mode = defaultMode):
        '''Returns a Module instance by slot number
        '''

        return Class(slot_ * 0x100000, size, mode)


    @classmethod
    def lun(Class, logicalUnitNumber = None):
        '''Returns a Module instance by the logical unit number (lun).

        The module has to be declared in the transfer.ref, i.e. CCDB.

        If no logical unit number is given, only one module must match
        (and it will be the one returned). Otherwise, it throws.
        '''

        modules = getModulesTransferRef()

        if len(modules) == 0:
            raise Exception('No matching module found in transfer.ref')

        if logicalUnitNumber is None:
            if len(modules) > 1:
                raise Exception('More than one matching module found in transfer.ref, but no logical unit number given')

            logicalUnitNumber = modules.keys()[0]

        if logicalUnitNumber not in modules:
            raise Exception('Logical number unit %s not in found matching modules: %s' % (logicalUnitNumber, modules.keys()))

        module = modules[logicalUnitNumber]

        # Assuming the address modifier is what we expect, i.e. just use
        # the data width to identify the mode
        mode = ModeA24D16 if module['dataWidth'] == 16 else ModeA32D32

        return Class(module['baseAddress'], module['size'], mode)


    def __init__(self, baseAddress, size = 0x100000, mode = ModeA24D16):
        object.__setattr__(self, 'mapping', VMEMapping(
            mode.addressModifier,
            mode.dataWidth,
            baseAddress,
            size
        ))

    def __setattr__(self, name, value):
        '''Since this class is used through properties rather than get/set
        member functions, misspelling a register name on a write
        (e.g. self.m.typo = 1) without noticing is a quite easy mistake to make.
        Therefore, prevent setting new attributes (no one should need
        to add new ones nor overwrite them dynamically anyway).
        '''

        if hasattr(self, name):            object.__setattr__(self, name, value)        else:            raise TypeError('Setting new attributes is not allowed (did you misspell a register?)')


    @property
    def control1(self):
        return self.mapping.read_u16(0x0)

    @control1.setter
    def control1(self, value):
        self.mapping.write_u16(0x0, value)

    @property
    def vmeIRQStatID(self):
        return self.mapping.read_u16(0x2)

    @vmeIRQStatID.setter
    def vmeIRQStatID(self, value):
        self.mapping.write_u16(0x2, value)

    @property
    def vmeIRQLevel(self):
        return self.mapping.read_u16(0x4)

    @vmeIRQLevel.setter
    def vmeIRQLevel(self, value):
        self.mapping.write_u16(0x4, value)

    @property
    def status1(self):
        return self.mapping.read_u16(0x6)

    @property
    def ident(self):
        return self.mapping.read_u16(0x8)

    @property
    def fault1(self):
        return self.mapping.read_u16(0xa)

    @property
    def fault2(self):
        return self.mapping.read_u16(0xc)

    @property
    def fault3(self):
        return self.mapping.read_u16(0xe)

    @property
    def faultFPC(self):
        return self.mapping.read_u16(0x10)

    @property
    def statusFPC(self):
        return self.mapping.read_u16(0x12)

    @property
    def debugControl(self):
        return self.mapping.read_u16(0x14)

    @debugControl.setter
    def debugControl(self, value):
        self.mapping.write_u16(0x14, value)

    @property
    def debugStatus(self):
        return self.mapping.read_u16(0x16)

    @property
    def debugFault(self):
        return self.mapping.read_u16(0x18)

    @property
    def debugFlag(self):
        return self.mapping.read_u16(0x1a)

    @property
    def nvMemStatus(self):
        return self.mapping.read_u16(0x2e)

    @property
    def nvMemControl(self):
        return self.mapping.read_u16(0x30)

    @nvMemControl.setter
    def nvMemControl(self, value):
        self.mapping.write_u16(0x30, value)

    @property
    def nvMemGetKey(self):
        return self.mapping.read_u16(0x32)

    @property
    def nvMemSetKey(self):
        return self.mapping.read_u16(0x34)

    @nvMemSetKey.setter
    def nvMemSetKey(self, value):
        self.mapping.write_u16(0x34, value)

    @property
    def nvMemCRCVal(self):
        return self.mapping.read_u16(0x36)

    @property
    def serdABCntrl(self):
        return self.mapping.read_u16(0x38)

    @serdABCntrl.setter
    def serdABCntrl(self, value):
        self.mapping.write_u16(0x38, value)

    @property
    def serdFpCntrl(self):
        return self.mapping.read_u16(0x3a)

    @serdFpCntrl.setter
    def serdFpCntrl(self, value):
        self.mapping.write_u16(0x3a, value)

    @property
    def serdABFpStat(self):
        return self.mapping.read_u16(0x3c)

    @property
    def serdAPRBSErrCnt(self):
        return self.mapping.read_u16(0x3e)

    @property
    def serdBPRBSErrCnt(self):
        return self.mapping.read_u16(0x40)

    @property
    def serdFPPRBSErrCnt(self):
        return self.mapping.read_u16(0x42)

    @property
    def serdARXReg(self):
        return self.mapping.read_u16(0x44)

    @property
    def serdBRXReg(self):
        return self.mapping.read_u16(0x46)

    @property
    def serdFPRXReg(self):
        return self.mapping.read_u16(0x48)

    @property
    def dspVersion(self):
        return self.mapping.read_u32(0x70)

    @property
    def dspSubVersion(self):
        return self.mapping.read_u16(0x74)

    @property
    def dspStatus(self):
        return self.mapping.read_u16(0x76)

    @property
    def dspFaults(self):
        return self.mapping.read_u16(0x78)

    @property
    def control2(self):
        return self.mapping.read_u16(0x7a)

    @control2.setter
    def control2(self, value):
        self.mapping.write_u16(0x7a, value)

    @property
    def control3(self):
        return self.mapping.read_u16(0x7c)

    @control3.setter
    def control3(self, value):
        self.mapping.write_u16(0x7c, value)

    @property
    def control4(self):
        return self.mapping.read_u16(0x7e)

    @control4.setter
    def control4(self, value):
        self.mapping.write_u16(0x7e, value)

    @property
    def status2(self):
        return self.mapping.read_u16(0x80)

    @property
    def rephB0(self):
        return self.mapping.read_float(0x82)

    @rephB0.setter
    def rephB0(self, value):
        self.mapping.write_float(0x82, value)

    @property
    def rephMq(self):
        return self.mapping.read_float(0x86)

    @rephMq.setter
    def rephMq(self, value):
        self.mapping.write_float(0x86, value)

    @property
    def rephGTrans(self):
        return self.mapping.read_float(0x8a)

    @rephGTrans.setter
    def rephGTrans(self, value):
        self.mapping.write_float(0x8a, value)

    @property
    def rephMaxSlope(self):
        return self.mapping.read_float(0x8e)

    @rephMaxSlope.setter
    def rephMaxSlope(self, value):
        self.mapping.write_float(0x8e, value)

    @property
    def rephSPSRad(self):
        return self.mapping.read_float(0x92)

    @rephSPSRad.setter
    def rephSPSRad(self, value):
        self.mapping.write_float(0x92, value)

    @property
    def rephFInf(self):
        return self.mapping.read_u32(0x96)

    @rephFInf.setter
    def rephFInf(self, value):
        self.mapping.write_u32(0x96, value)

    @property
    def rephMuValue(self):
        return self.mapping.read_float(0x9a)

    @rephMuValue.setter
    def rephMuValue(self, value):
        self.mapping.write_float(0x9a, value)

    @property
    def rephHarmNum(self):
        return self.mapping.read_u32(0x9e)

    @rephHarmNum.setter
    def rephHarmNum(self, value):
        self.mapping.write_u32(0x9e, value)

    @property
    def rephCFPCal(self):
        return self.mapping.read_float(0xa2)

    @rephCFPCal.setter
    def rephCFPCal(self, value):
        self.mapping.write_float(0xa2, value)

    @property
    def rephS1TargetFreq(self):
        return self.mapping.read_u32(0xa6)

    @rephS1TargetFreq.setter
    def rephS1TargetFreq(self, value):
        self.mapping.write_u32(0xa6, value)

    @property
    def rephS1MaxdF(self):
        return self.mapping.read_float(0xaa)

    @rephS1MaxdF.setter
    def rephS1MaxdF(self, value):
        self.mapping.write_float(0xaa, value)

    @property
    def rephS1FreqLSBF(self):
        return self.mapping.read_u16(0xae)

    @rephS1FreqLSBF.setter
    def rephS1FreqLSBF(self, value):
        self.mapping.write_u16(0xae, value)

    @property
    def rephS2DeltaT(self):
        return self.mapping.read_float(0xb0)

    @rephS2DeltaT.setter
    def rephS2DeltaT(self, value):
        self.mapping.write_float(0xb0, value)

    @property
    def rephS2MaxdF(self):
        return self.mapping.read_float(0xb4)

    @rephS2MaxdF.setter
    def rephS2MaxdF(self, value):
        self.mapping.write_float(0xb4, value)

    @property
    def udCounter(self):
        return self.mapping.read_u32(0xb8)

    @property
    def radialSteering(self):
        return self.mapping.read_u16(0xbc)

    @property
    def coarseFP(self):
        return self.mapping.read_u16(0xbe)

    @property
    def ddsFTW1(self):
        return self.mapping.read_u32(0xc0)

    @property
    def ddsFTW2(self):
        return self.mapping.read_u32(0xc4)

    @property
    def bpTotalRecSize(self):
        return self.mapping.read_u32(0xc8)

    @property
    def bpTotalPbckSize(self):
        return self.mapping.read_u32(0xcc)

    @bpTotalPbckSize.setter
    def bpTotalPbckSize(self, value):
        self.mapping.write_u32(0xcc, value)

    @property
    def r2stTargetFreq(self):
        return self.mapping.read_u32(0xd0)

    @r2stTargetFreq.setter
    def r2stTargetFreq(self, value):
        self.mapping.write_u32(0xd0, value)

    @property
    def currentFProg(self):
        return self.mapping.read_s32(0xd4)

    @property
    def sysControl(self):
        return self.mapping.read_u16(0xe0)

    @sysControl.setter
    def sysControl(self, value):
        self.mapping.write_u16(0xe0, value)

    @property
    def hardwareVersion(self):
        return self.mapping.read_u16(0xe2)

    @property
    def designerID(self):
        return self.mapping.read_u16(0xe4)

    @property
    def boardTemp(self):
        return self.mapping.read_u16(0xe6)

    @property
    def chipTemp(self):
        return self.mapping.read_u16(0xe8)

    @property
    def testControl(self):
        return self.mapping.read_u16(0xea)

    @testControl.setter
    def testControl(self, value):
        self.mapping.write_u16(0xea, value)

    @property
    def testStatus(self):
        return self.mapping.read_u16(0xec)

    @property
    def firmwareVersion(self):
        return self.mapping.read_u32(0xf0)

    @property
    def serialNumber(self):
        return self.mapping.read_u64(0xf4)

    @property
    def memMapVersion(self):
        return self.mapping.read_u32(0xfc)

    @property
    def acqBufSel(self):
        return self.mapping.read_u16(0x100)

    @acqBufSel.setter
    def acqBufSel(self, value):
        self.mapping.write_u16(0x100, value)

    @property
    def acqPageSel(self):
        return self.mapping.read_u16(0x102)

    @acqPageSel.setter
    def acqPageSel(self, value):
        self.mapping.write_u16(0x102, value)

    @property
    def acqFrzAddr(self):
        return self.mapping.read_u32(0x104)

    @property
    def acqStatus(self):
        return self.mapping.read_u16(0x108)

    @property
    def acqSize(self):
        return self.mapping.read_u32(0x10a)

    @property
    def acqControl(self):
        return self.mapping.read_u16(0x10e)

    @acqControl.setter
    def acqControl(self, value):
        self.mapping.write_u16(0x10e, value)

    @property
    def acqTrigSel(self):
        return self.mapping.read_u32(0x110)

    @acqTrigSel.setter
    def acqTrigSel(self, value):
        self.mapping.write_u32(0x110, value)

    @property
    def acqMethod(self):
        return self.mapping.read_u16(0x114)

    @acqMethod.setter
    def acqMethod(self, value):
        self.mapping.write_u16(0x114, value)

    @property
    def acqRateSel(self):
        return self.mapping.read_u16(0x116)

    @acqRateSel.setter
    def acqRateSel(self, value):
        self.mapping.write_u16(0x116, value)

    @property
    def dbgCntIrq0(self):
        return self.mapping.read_u32(0x130)

    @property
    def dbgCntIrq1(self):
        return self.mapping.read_u32(0x134)

    @property
    def dbgDspCntIrq0(self):
        return self.mapping.read_u32(0x138)

    @property
    def dbgDspCntIrq1(self):
        return self.mapping.read_u32(0x13c)

    @property
    def dbgIrq0Cnt20ns(self):
        return self.mapping.read_u16(0x140)

    @property
    def dbgIrq0IsrBegin(self):
        return self.mapping.read_u16(0x142)

    @property
    def dbgIrq0IsrEnd(self):
        return self.mapping.read_u16(0x144)

    @property
    def dbgRdRegD20ns(self):
        return self.mapping.read_u32(0x146)

    @property
    def dbgRSfromSL(self):
        return self.mapping.read_u16(0x14a)

    @property
    def dbgRSfromFGSCL(self):
        return self.mapping.read_u16(0x14c)

    @property
    def dbgObsMemLastAddr(self):
        return self.mapping.read_u32(0x14e)

    @property
    def dbgObsMemLastData(self):
        return self.mapping.read_u32(0x152)

    @property
    def dbgObsFrzTimerVal(self):
        return self.mapping.read_u32(0x156)

    @dbgObsFrzTimerVal.setter
    def dbgObsFrzTimerVal(self, value):
        self.mapping.write_u32(0x156, value)

    @property
    def sizeofDspStatusMem(self):
        return self.mapping.read_u32(0x15a)

    @property
    def dbgDataRd1(self):
        return self.mapping.read_u32(0x15e)

    @property
    def dbgDataRd2(self):
        return self.mapping.read_u32(0x162)

    @property
    def dbgDataRd3(self):
        return self.mapping.read_u32(0x166)

    @property
    def dspPrgControl(self):
        return self.mapping.read_u16(0x7f0)

    @dspPrgControl.setter
    def dspPrgControl(self, value):
        self.mapping.write_u16(0x7f0, value)

    @property
    def dspPrgStatus(self):
        return self.mapping.read_u16(0x7f2)

    @property
    def dspPrgFileSize(self):
        return self.mapping.read_u32(0x7f4)

    @dspPrgFileSize.setter
    def dspPrgFileSize(self, value):
        self.mapping.write_u32(0x7f4, value)

    @property
    def dspPrgDebug(self):
        return self.mapping.read_u32(0x7f8)


