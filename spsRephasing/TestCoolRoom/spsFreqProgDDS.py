'''spsFreqProgDDS Hardware Test Python module

Automatically generated by Topple 0.0.1
'''


__author__ = 'Miguel Ojeda'
__copyright__ = 'Copyright 2015, CERN BE'
__credits__ = ['Miguel Ojeda']
__license__ = 'Unknown'
__maintainer__ = 'Miguel Ojeda'
__email__ = 'mos@cern.ch'


import ctypes
import platform
import struct


class libvmebus(object):
    '''Minimal libvmebus Python binding (with only our needed bits)
    '''

    cpu = 'L865' if platform.machine() == 'i686' else 'L866'
    lib = ctypes.CDLL('/acc/local/%s/drv/vmebus/pyvmelib/libvmebus.so' % cpu)
    vme_map = lib.vme_map
    vme_map.restype = ctypes.c_void_p

    VME_A24_USER_DATA_SCT = 0x39
    VME_A32_USER_DATA_SCT = 0x09
    VME_D16 = 16
    VME_D32 = 32

    class vme_mapping(ctypes.Structure):
        _fields_ = [
	        ('window_num', ctypes.c_int),
	        ('*kernel_va', ctypes.c_void_p),
	        ('user_va', ctypes.c_void_p),
	        ('fd', ctypes.c_int),
	        ('window_enabled', ctypes.c_int),
	        ('data_width', ctypes.c_int),
	        ('am', ctypes.c_int),
	        ('read_prefetch_enabled', ctypes.c_int),
	        ('read_prefetch_size', ctypes.c_int),
	        ('v2esst_mode', ctypes.c_int),
	        ('bcast_select', ctypes.c_int),
	        ('pci_addru', ctypes.c_uint),
	        ('pci_addrl', ctypes.c_uint),
	        ('sizeu', ctypes.c_uint),
	        ('sizel', ctypes.c_uint),
	        ('vme_addru', ctypes.c_uint),
	        ('vme_addrl', ctypes.c_uint),
        ]


def interpret(value, ctype, swapped, fromHardware):
    '''Interpret raw input value as an signed/unsigned integer (according
    to the specified type) and possibly swapped as well (endianess change).
    Same for the other way (fromHardware): convert a Python integer to
    the proper raw value for VME.
    '''

    unsignedFormatBySize = {
        1: 'B',
        2: 'H',
        4: 'L',
        8: 'Q',
    }

    size = ctypes.sizeof(ctype)

    signed = ctype in (
        ctypes.c_byte,
        ctypes.c_short,
        ctypes.c_int,
        ctypes.c_long,
        ctypes.c_longlong,
    )

    inputByteOrder = '<'
    outputByteOrder = '<'
    inputFormat = unsignedFormatBySize[size]
    outputFormat = unsignedFormatBySize[size]

    if swapped:
        outputByteOrder = '>'
    if signed:
        if fromHardware:
            outputFormat = outputFormat.lower()
        else:
            inputFormat = inputFormat.lower()

    return struct.unpack(outputByteOrder + outputFormat, struct.pack(inputByteOrder + inputFormat, value))[0]


class VMEMapping(object):
    '''Minimal Python class to map the VME bus, based on pyvmelib/libvmebus
    '''

    _typeBySize = {
        1: ctypes.c_ubyte,
        2: ctypes.c_ushort,
        4: ctypes.c_uint,
        8: ctypes.c_ulonglong,
    }

    def __init__(self, addressModifier, dataWidth, baseAddress, size):
        self.dataWidth = dataWidth

        self.mapping = libvmebus.vme_mapping()
        self.mapping.am                    = addressModifier
        self.mapping.data_width            = dataWidth
        self.mapping.vme_addru             = 0
        self.mapping.vme_addrl             = baseAddress
        self.mapping.sizeu                 = 0
        self.mapping.sizel                 = size
        self.mapping.read_prefetch_enabled = 0
        self.mapping.bcast_select          = 0
        self.mapping.window_num            = 0

        self.virtualAddress = libvmebus.vme_map(ctypes.byref(self.mapping), 1)
        if self.virtualAddress is None:
            raise Exception('Error while mapping VME window')


    def pointer(self, offset, ctype):
        '''Returns an unsigned pointer to the specified offset
        '''

        return ctypes.cast(self.virtualAddress + offset, ctypes.POINTER(self._typeBySize[ctypes.sizeof(ctype)]))


    def readList(self, offset, ctype, n):
        '''Reads a list of values at the specified offset
        '''

        address = self.pointer(offset, ctype)
        return [interpret(address[i], ctype, True, True) for i in range(n)]


    def writeList(self, offset, ctype, values):
        '''Writes a list of values at the specified offset
        '''

        # TODO: check values
        address = self.pointer(offset, ctype)
        for i in range(len(values)):
            address[i] = interpret(values[i], ctype, True, False)


    def read(self, offset, ctype):
        '''Reads a single register at the specified offset
        '''

        return self.readList(offset, ctype, 1)[0]


    def write(self, offset, ctype, value):
        '''Writes a single register at the specified offset
        '''

        self.writeList(offset, ctype, [value])


    def read_u8(self, offset):
        return self.read(offset, ctypes.c_ubyte)
    def read_u16(self, offset):
        return self.read(offset, ctypes.c_ushort)
    def read_u32(self, offset):
        return self.read(offset, ctypes.c_uint)
    def read_u64(self, offset):
        return self.read(offset, ctypes.c_ulonglong)


    def read_s8(self, offset):
        return self.read(offset, ctypes.c_byte)
    def read_s16(self, offset):
        return self.read(offset, ctypes.c_short)
    def read_s32(self, offset):
        return self.read(offset, ctypes.c_int)
    def read_s64(self, offset):
        return self.read(offset, ctypes.c_longlong)


    def write_u8(self, offset, value):
        self.write(offset, ctypes.c_ubyte, value)
    def write_u16(self, offset, value):
        self.write(offset, ctypes.c_ushort, value)
    def write_u32(self, offset, value):
        self.write(offset, ctypes.c_uint, value)
    def write_u64(self, offset, value):
        self.write(offset, ctypes.c_ulonglong, value)


    def write_s8(self, offset, value):
        self.write(offset, ctypes.c_byte, value)
    def write_s16(self, offset, value):
        self.write(offset, ctypes.c_short, value)
    def write_s32(self, offset, value):
        self.write(offset, ctypes.c_int, value)
    def write_s64(self, offset, value):
        self.write(offset, ctypes.c_longlong, value)


class Mode(object):
    '''VME modes for RF crates
    '''

    pass

class ModeA24D16(Mode):
    addressModifier = libvmebus.VME_A24_USER_DATA_SCT
    dataWidth = libvmebus.VME_D16

class ModeA32D32(Mode):
    addressModifier = libvmebus.VME_A32_USER_DATA_SCT
    dataWidth = libvmebus.VME_D32


defaultSize = 0x50000
defaultMode = ModeA24D16


def getModulesTransferRef():
    '''Get a dictionary of matching devices in the transfer.ref.

    The key of the map is the logical unit number (lun).

    TODO: parse the rest of the columns (e.g. second address window) as well
    '''

    moduleType = 'RF_SPS_FP_DDS'
    modules = {}
    with open('/etc/transfer.ref', 'rb') as fd:
        for line in fd.readlines():
            if '#+#' in line and moduleType in line:
                tokens = line.strip().split()

                if tokens[3] != 'VME':
                    raise Exception('Non-VME module found (should not happen?)')

                logicalUnitNumber = int(tokens[6])
                if logicalUnitNumber in modules:
                    raise Exception('Several matching modules with the same logical unit number (should not happen?)')

                dataPortSize = tokens[9]
                if not dataPortSize.startswith('DP'):
                    raise Exception('Unrecognized data port size')

                modules[logicalUnitNumber] = {
                    'logicalUnitNumber': logicalUnitNumber,
                    'addressModifier': tokens[8],
                    'dataWidth': int(dataPortSize[2:]),
                    'baseAddress': int(tokens[10], 16),
                    'size': int(tokens[11], 16),
                    'slot': int(tokens[19]) - 6,
                }

    return modules


class Module(object):
    '''Generated VME module abstraction
    '''

    @classmethod
    def slot(Class, slot_, size = defaultSize, mode = defaultMode):
        '''Returns a Module instance by slot number
        '''

        return Class(slot_ * 0x100000, size, mode)


    @classmethod
    def lun(Class, logicalUnitNumber = None):
        '''Returns a Module instance by the logical unit number (lun).

        The module has to be declared in the transfer.ref, i.e. CCDB.

        If no logical unit number is given, only one module must match
        (and it will be the one returned). Otherwise, it throws.
        '''

        modules = getModulesTransferRef()

        if len(modules) == 0:
            raise Exception('No matching module found in transfer.ref')

        if logicalUnitNumber is None:
            if len(modules) > 1:
                raise Exception('More than one matching module found in transfer.ref, but no logical unit number given')

            logicalUnitNumber = modules.keys()[0]

        if logicalUnitNumber not in modules:
            raise Exception('Logical number unit %s not in found matching modules: %s' % (logicalUnitNumber, modules.keys()))

        module = modules[logicalUnitNumber]

        # Assuming the address modifier is what we expect, i.e. just use
        # the data width to identify the mode
        mode = ModeA24D16 if module['dataWidth'] == 16 else ModeA32D32

        return Class(module['baseAddress'], module['size'], mode)


    def __init__(self, baseAddress, size = 0x100000, mode = ModeA24D16):
        self.mapping = VMEMapping(
            mode.addressModifier,
            mode.dataWidth,
            baseAddress,
            size
        )


    @property
    def control1(self):
        return self.mapping.read_u16(0x0)

    @control1.setter
    def control1(self, value):
        self.mapping.write_u16(0x0, value)

    @property
    def vmeIRQStatID(self):
        return self.mapping.read_u16(0x2)

    @vmeIRQStatID.setter
    def vmeIRQStatID(self, value):
        self.mapping.write_u16(0x2, value)

    @property
    def vmeIRQLevel(self):
        return self.mapping.read_u16(0x4)

    @vmeIRQLevel.setter
    def vmeIRQLevel(self, value):
        self.mapping.write_u16(0x4, value)

    @property
    def status1(self):
        return self.mapping.read_u16(0x6)

    @property
    def ident(self):
        return self.mapping.read_u16(0x8)

    @property
    def pmAddr(self):
        return self.mapping.read_u32(0xa)

    @property
    def obsAddr(self):
        return self.mapping.read_u32(0xe)

    @property
    def control2(self):
        return self.mapping.read_u16(0x12)

    @control2.setter
    def control2(self, value):
        self.mapping.write_u16(0x12, value)

    @property
    def control3(self):
        return self.mapping.read_u16(0x14)

    @control3.setter
    def control3(self, value):
        self.mapping.write_u16(0x14, value)

    @property
    def serialFTW(self):
        return self.mapping.read_u32(0x20)

    @property
    def fskFTW(self):
        return self.mapping.read_u32(0x24)

    @fskFTW.setter
    def fskFTW(self, value):
        self.mapping.write_u32(0x24, value)

    @property
    def faults(self):
        return self.mapping.read_u16(0x28)

    @property
    def flags(self):
        return self.mapping.read_u16(0x2a)

    @property
    def bpTrigSel(self):
        return self.mapping.read_u16(0x2c)

    @bpTrigSel.setter
    def bpTrigSel(self, value):
        self.mapping.write_u16(0x2c, value)

    @property
    def delay1(self):
        return self.mapping.read_u16(0x2e)

    @property
    def delay2(self):
        return self.mapping.read_u16(0x30)

    @property
    def ddsData(self):
        return self.mapping.read_u32(0x40)

    @ddsData.setter
    def ddsData(self, value):
        self.mapping.write_u32(0x40, value)

    @property
    def ddsRegSel(self):
        return self.mapping.read_u16(0x44)

    @ddsRegSel.setter
    def ddsRegSel(self, value):
        self.mapping.write_u16(0x44, value)

    @property
    def debugControl(self):
        return self.mapping.read_u16(0x46)

    @debugControl.setter
    def debugControl(self, value):
        self.mapping.write_u16(0x46, value)

    @property
    def debugFlags(self):
        return self.mapping.read_u16(0x48)

    @property
    def debugStatus(self):
        return self.mapping.read_u16(0x4a)

    @property
    def debugData1(self):
        return self.mapping.read_u16(0x4c)

    @property
    def debugData2(self):
        return self.mapping.read_u16(0x4e)

    @property
    def debugData3(self):
        return self.mapping.read_u32(0x50)

    @property
    def debugData4(self):
        return self.mapping.read_u32(0x54)

    @property
    def debugData5(self):
        return self.mapping.read_u32(0x58)

    @debugData5.setter
    def debugData5(self, value):
        self.mapping.write_u32(0x58, value)

    @property
    def debugData6(self):
        return self.mapping.read_u32(0x5c)

    @debugData6.setter
    def debugData6(self, value):
        self.mapping.write_u32(0x5c, value)

    @property
    def debugData7(self):
        return self.mapping.read_u32(0x60)

    @debugData7.setter
    def debugData7(self, value):
        self.mapping.write_u32(0x60, value)

    @property
    def dbgMLAwr(self):
        return self.mapping.read_u32(0x64)

    @property
    def dbgMLArd(self):
        return self.mapping.read_u32(0x68)

    @property
    def dbgMLDwr(self):
        return self.mapping.read_u32(0x6c)

    @property
    def dbgMLDrd(self):
        return self.mapping.read_u16(0x70)

    @property
    def debugSentFSKFTW(self):
        return self.mapping.read_u32(0x72)

    @property
    def overflows1(self):
        return self.mapping.read_u16(0x100)

    @property
    def acqBufSel(self):
        return self.mapping.read_u16(0x102)

    @acqBufSel.setter
    def acqBufSel(self, value):
        self.mapping.write_u16(0x102, value)

    @property
    def acqPageSel(self):
        return self.mapping.read_u16(0x104)

    @acqPageSel.setter
    def acqPageSel(self, value):
        self.mapping.write_u16(0x104, value)

    @property
    def acqFrzAddr(self):
        return self.mapping.read_u32(0x106)

    @property
    def acqSize(self):
        return self.mapping.read_u32(0x10a)

    @property
    def acqStatus(self):
        return self.mapping.read_u16(0x10e)

    @property
    def acqControl(self):
        return self.mapping.read_u16(0x110)

    @acqControl.setter
    def acqControl(self, value):
        self.mapping.write_u16(0x110, value)

    @property
    def acqTrigSel(self):
        return self.mapping.read_u32(0x112)

    @acqTrigSel.setter
    def acqTrigSel(self, value):
        self.mapping.write_u32(0x112, value)

    @property
    def acqRateSel(self):
        return self.mapping.read_u16(0x116)

    @acqRateSel.setter
    def acqRateSel(self, value):
        self.mapping.write_u16(0x116, value)

    @property
    def acqMethod(self):
        return self.mapping.read_u16(0x118)

    @acqMethod.setter
    def acqMethod(self, value):
        self.mapping.write_u16(0x118, value)

    @property
    def serdCntrl(self):
        return self.mapping.read_u16(0x11a)

    @serdCntrl.setter
    def serdCntrl(self, value):
        self.mapping.write_u16(0x11a, value)

    @property
    def serdRXReg(self):
        return self.mapping.read_u16(0x11c)

    @property
    def serdPRBScnt(self):
        return self.mapping.read_u16(0x11e)

    @property
    def sysControl(self):
        return self.mapping.read_u16(0xe0)

    @sysControl.setter
    def sysControl(self, value):
        self.mapping.write_u16(0xe0, value)

    @property
    def hardwareVersion(self):
        return self.mapping.read_u16(0xe2)

    @property
    def designerID(self):
        return self.mapping.read_u16(0xe4)

    @property
    def boardTemp(self):
        return self.mapping.read_s16(0xe6)

    @property
    def testControl(self):
        return self.mapping.read_u16(0xec)

    @testControl.setter
    def testControl(self, value):
        self.mapping.write_u16(0xec, value)

    @property
    def testStatus(self):
        return self.mapping.read_u16(0xee)

    @property
    def firmwareVersion(self):
        return self.mapping.read_u32(0xf0)

    @property
    def serialNumber(self):
        return self.mapping.read_u64(0xf4)

    @property
    def memMapVersion(self):
        return self.mapping.read_u32(0xfc)

    @property
    def mddsADCGain(self):
        return self.mapping.read_u16(0x200)

    @mddsADCGain.setter
    def mddsADCGain(self, value):
        self.mapping.write_u16(0x200, value)

    @property
    def mddsADCOffset(self):
        return self.mapping.read_s16(0x202)

    @mddsADCOffset.setter
    def mddsADCOffset(self, value):
        self.mapping.write_s16(0x202, value)

    @property
    def mddsCFPGain(self):
        return self.mapping.read_u32(0x204)

    @mddsCFPGain.setter
    def mddsCFPGain(self, value):
        self.mapping.write_u32(0x204, value)

    @property
    def mddsCFPOffset(self):
        return self.mapping.read_s32(0x208)

    @mddsCFPOffset.setter
    def mddsCFPOffset(self, value):
        self.mapping.write_s32(0x208, value)

    @property
    def mddsDbgADC(self):
        return self.mapping.read_u16(0x20c)

    @property
    def mddsDbgPhErr(self):
        return self.mapping.read_u32(0x20e)

    @property
    def mddsDbgCFP(self):
        return self.mapping.read_u16(0x212)

    @property
    def mddsDbgCFPFTW(self):
        return self.mapping.read_u32(0x214)

    @property
    def mddsFTW(self):
        return self.mapping.read_u32(0x218)

    @property
    def mddsPowLevClk125(self):
        return self.mapping.read_u16(0x21c)

    @property
    def mddsFaults(self):
        return self.mapping.read_u16(0x21e)

    @property
    def mddsStatus(self):
        return self.mapping.read_u16(0x220)

    @property
    def mddsControl(self):
        return self.mapping.read_u16(0x222)

    @mddsControl.setter
    def mddsControl(self, value):
        self.mapping.write_u16(0x222, value)


