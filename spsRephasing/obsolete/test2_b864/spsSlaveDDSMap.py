'''spsSlaveDDSMap Hardware Test Python module

Automatically generated by Topple 0.0.1
'''


__author__ = 'Miguel Ojeda'
__copyright__ = 'Copyright 2015, CERN BE'
__credits__ = ['Miguel Ojeda']
__license__ = 'Unknown'
__maintainer__ = 'Miguel Ojeda'
__email__ = 'mos@cern.ch'


import ctypes
import platform
import struct


class libvmebus(object):
    '''Minimal libvmebus Python binding (with only our needed bits)
    '''

    cpu = 'L865' if platform.machine() == 'i686' else 'L866'
    lib = ctypes.CDLL('/acc/local/%s/drv/vmebus/pyvmelib/libvmebus.so' % cpu)
    vme_map = lib.vme_map
    vme_map.restype = ctypes.c_void_p

    VME_A24_USER_DATA_SCT = 0x39
    VME_A32_USER_DATA_SCT = 0x09
    VME_D16 = 16
    VME_D32 = 32

    class vme_mapping(ctypes.Structure):
        _fields_ = [
	        ('window_num', ctypes.c_int),
	        ('*kernel_va', ctypes.c_void_p),
	        ('user_va', ctypes.c_void_p),
	        ('fd', ctypes.c_int),
	        ('window_enabled', ctypes.c_int),
	        ('data_width', ctypes.c_int),
	        ('am', ctypes.c_int),
	        ('read_prefetch_enabled', ctypes.c_int),
	        ('read_prefetch_size', ctypes.c_int),
	        ('v2esst_mode', ctypes.c_int),
	        ('bcast_select', ctypes.c_int),
	        ('pci_addru', ctypes.c_uint),
	        ('pci_addrl', ctypes.c_uint),
	        ('sizeu', ctypes.c_uint),
	        ('sizel', ctypes.c_uint),
	        ('vme_addru', ctypes.c_uint),
	        ('vme_addrl', ctypes.c_uint),
        ]


def interpret(value, ctype, swapped):
    '''Interpret raw input value as an signed/unsigned integer (according
    to the specified type) and possibly swapped as well (endianess change).
    '''

    unsignedFormatBySize = {
        1: 'B',
        2: 'H',
        4: 'L',
        8: 'Q',
    }

    size = ctypes.sizeof(ctype)

    signed = ctype in (
        ctypes.c_byte,
        ctypes.c_short,
        ctypes.c_int,
        ctypes.c_long,
        ctypes.c_longlong,
    )

    inputByteOrder = '<'
    outputByteOrder = '<'
    inputFormat = unsignedFormatBySize[size]
    outputFormat = unsignedFormatBySize[size]

    if swapped:
        outputByteOrder = '>'
    if signed:
        outputFormat = outputFormat.lower()

    return struct.unpack(outputByteOrder + outputFormat, struct.pack(inputByteOrder + inputFormat, value))[0]


class VMEMapping(object):
    '''Minimal Python class to map the VME bus, based on pyvmelib/libvmebus
    '''

    _typeBySize = {
        1: ctypes.c_ubyte,
        2: ctypes.c_ushort,
        4: ctypes.c_uint,
        8: ctypes.c_ulonglong,
    }

    def __init__(self, addressModifier, dataWidth, baseAddress, size):
        self.dataWidth = dataWidth

        self.mapping = libvmebus.vme_mapping()
        self.mapping.am                    = addressModifier
        self.mapping.data_width            = dataWidth
        self.mapping.vme_addru             = 0
        self.mapping.vme_addrl             = baseAddress
        self.mapping.sizeu                 = 0
        self.mapping.sizel                 = size
        self.mapping.read_prefetch_enabled = 0
        self.mapping.bcast_select          = 0
        self.mapping.window_num            = 0

        self.virtualAddress = libvmebus.vme_map(ctypes.byref(self.mapping), 1)
        if self.virtualAddress is None:
            raise Exception('Error while mapping VME window')


    def pointer(self, offset, ctype):
        '''Returns an unsigned pointer to the specified offset
        '''

        return ctypes.cast(self.virtualAddress + offset, ctypes.POINTER(self._typeBySize[ctypes.sizeof(ctype)]))


    def readList(self, offset, ctype, n):
        '''Reads a list of values at the specified offset
        '''

        address = self.pointer(offset, ctype)
        return [interpret(address[i], ctype, True) for i in range(n)]


    def writeList(self, offset, ctype, values):
        '''Writes a list of values at the specified offset
        '''

        # TODO: check values
        address = self.pointer(offset, ctype)
        for i in range(len(values)):
            address[i] = interpret(values[i], ctype, True)


    def read(self, offset, ctype):
        '''Reads a single register at the specified offset
        '''

        return self.readList(offset, ctype, 1)[0]


    def write(self, offset, ctype, value):
        '''Writes a single register at the specified offset
        '''

        self.writeList(offset, ctype, [value])


    def read_u8(self, offset):
        return self.read(offset, ctypes.c_ubyte)
    def read_u16(self, offset):
        return self.read(offset, ctypes.c_ushort)
    def read_u32(self, offset):
        return self.read(offset, ctypes.c_uint)
    def read_u64(self, offset):
        return self.read(offset, ctypes.c_ulonglong)


    def read_s8(self, offset):
        return self.read(offset, ctypes.c_byte)
    def read_s16(self, offset):
        return self.read(offset, ctypes.c_short)
    def read_s32(self, offset):
        return self.read(offset, ctypes.c_int)
    def read_s64(self, offset):
        return self.read(offset, ctypes.c_longlong)


    def write_u8(self, offset, value):
        self.write(offset, ctypes.c_ubyte, value)
    def write_u16(self, offset, value):
        self.write(offset, ctypes.c_ushort, value)
    def write_u32(self, offset, value):
        self.write(offset, ctypes.c_uint, value)
    def write_u64(self, offset, value):
        self.write(offset, ctypes.c_ulonglong, value)


    def write_s8(self, offset, value):
        self.write(offset, ctypes.c_byte, value)
    def write_s16(self, offset, value):
        self.write(offset, ctypes.c_short, value)
    def write_s32(self, offset, value):
        self.write(offset, ctypes.c_int, value)
    def write_s64(self, offset, value):
        self.write(offset, ctypes.c_longlong, value)


class Mode(object):
    '''VME modes for RF crates
    '''

    pass

class ModeA24D16(Mode):
    addressModifier = libvmebus.VME_A24_USER_DATA_SCT
    dataWidth = libvmebus.VME_D16

class ModeA32D32(Mode):
    addressModifier = libvmebus.VME_A32_USER_DATA_SCT
    dataWidth = libvmebus.VME_D32


defaultSize = 0x50000
defaultMode = ModeA24D16


def getModulesTransferRef():
    '''Get a dictionary of matching devices in the transfer.ref.

    The key of the map is the logical unit number (lun).

    TODO: parse the rest of the columns (e.g. second address window) as well
    '''

    moduleType = 'RF_SPS_SDDS'
    modules = {}
    with open('/etc/transfer.ref', 'rb') as fd:
        for line in fd.readlines():
            if '#+#' in line and moduleType in line:
                tokens = line.strip().split()

                if tokens[3] != 'VME':
                    raise Exception('Non-VME module found (should not happen?)')

                logicalUnitNumber = int(tokens[6])
                if logicalUnitNumber in modules:
                    raise Exception('Several matching modules with the same logical unit number (should not happen?)')

                dataPortSize = tokens[9]
                if not dataPortSize.startswith('DP'):
                    raise Exception('Unrecognized data port size')

                modules[logicalUnitNumber] = {
                    'logicalUnitNumber': logicalUnitNumber,
                    'addressModifier': tokens[8],
                    'dataWidth': int(dataPortSize[2:]),
                    'baseAddress': int(tokens[10], 16),
                    'size': int(tokens[11], 16),
                    'slot': int(tokens[19]) - 6,
                }

    return modules


class Module(object):
    '''Generated VME module abstraction
    '''

    @classmethod
    def slot(Class, slot_, size = defaultSize, mode = defaultMode):
        '''Returns a Module instance by slot number
        '''

        return Class(slot_ * 0x100000, size, mode)


    @classmethod
    def lun(Class, logicalUnitNumber = None):
        '''Returns a Module instance by the logical unit number (lun).

        The module has to be declared in the transfer.ref, i.e. CCDB.

        If no logical unit number is given, only one module must match
        (and it will be the one returned). Otherwise, it throws.
        '''

        modules = getModulesTransferRef()

        if len(modules) == 0:
            raise Exception('No matching module found in transfer.ref')

        if logicalUnitNumber is None:
            if len(modules) > 1:
                raise Exception('More than one matching module found in transfer.ref, but no logical unit number given')

            logicalUnitNumber = modules.keys()[0]

        if logicalUnitNumber not in modules:
            raise Exception('Logical number unit %s not in found matching modules: %s' % (logicalUnitNumber, modules.keys()))

        module = modules[logicalUnitNumber]

        # Assuming the address modifier is what we expect, i.e. just use
        # the data width to identify the mode
        mode = ModeA24D16 if module['dataWidth'] == 16 else ModeA32D32

        return Class(module['baseAddress'], module['size'], mode)


    def __init__(self, baseAddress, size = 0x100000, mode = ModeA24D16):
        self.mapping = VMEMapping(
            mode.addressModifier,
            mode.dataWidth,
            baseAddress,
            size
        )


    @property
    def control1(self):
        return self.mapping.read_u16(0x0)

    @control1.setter
    def control1(self, value):
        self.mapping.write_u16(0x0, value)

    @property
    def vmeIRQStatID(self):
        return self.mapping.read_u16(0x2)

    @vmeIRQStatID.setter
    def vmeIRQStatID(self, value):
        self.mapping.write_u16(0x2, value)

    @property
    def vmeIRQLevel(self):
        return self.mapping.read_u16(0x4)

    @vmeIRQLevel.setter
    def vmeIRQLevel(self, value):
        self.mapping.write_u16(0x4, value)

    @property
    def status1(self):
        return self.mapping.read_u16(0x6)

    @property
    def ident(self):
        return self.mapping.read_u16(0x8)

    @property
    def control2(self):
        return self.mapping.read_u16(0xa)

    @control2.setter
    def control2(self, value):
        self.mapping.write_u16(0xa, value)

    @property
    def control3(self):
        return self.mapping.read_u16(0xc)

    @control3.setter
    def control3(self, value):
        self.mapping.write_u16(0xc, value)

    @property
    def rfOnOffset(self):
        return self.mapping.read_u16(0x20)

    @rfOnOffset.setter
    def rfOnOffset(self, value):
        self.mapping.write_u16(0x20, value)

    @property
    def rfOffOffset(self):
        return self.mapping.read_u16(0x22)

    @rfOffOffset.setter
    def rfOffOffset(self, value):
        self.mapping.write_u16(0x22, value)

    @property
    def minDFTW1(self):
        return self.mapping.read_u32(0x24)

    @minDFTW1.setter
    def minDFTW1(self, value):
        self.mapping.write_u32(0x24, value)

    @property
    def maxDFTW1(self):
        return self.mapping.read_u32(0x28)

    @maxDFTW1.setter
    def maxDFTW1(self, value):
        self.mapping.write_u32(0x28, value)

    @property
    def minFTW1(self):
        return self.mapping.read_u32(0x2c)

    @minFTW1.setter
    def minFTW1(self, value):
        self.mapping.write_u32(0x2c, value)

    @property
    def maxFTW1(self):
        return self.mapping.read_u32(0x30)

    @maxFTW1.setter
    def maxFTW1(self, value):
        self.mapping.write_u32(0x30, value)

    @property
    def frevPhaseOffset(self):
        return self.mapping.read_u16(0x34)

    @frevPhaseOffset.setter
    def frevPhaseOffset(self, value):
        self.mapping.write_u16(0x34, value)

    @property
    def faults(self):
        return self.mapping.read_u16(0x36)

    @property
    def ddsData(self):
        return self.mapping.read_u32(0x40)

    @ddsData.setter
    def ddsData(self, value):
        self.mapping.write_u32(0x40, value)

    @property
    def ddsRegSel(self):
        return self.mapping.read_u16(0x44)

    @ddsRegSel.setter
    def ddsRegSel(self, value):
        self.mapping.write_u16(0x44, value)

    @property
    def ddsControl(self):
        return self.mapping.read_u16(0x46)

    @ddsControl.setter
    def ddsControl(self, value):
        self.mapping.write_u16(0x46, value)

    @property
    def ddsControl2(self):
        return self.mapping.read_u16(0x48)

    @ddsControl2.setter
    def ddsControl2(self, value):
        self.mapping.write_u16(0x48, value)

    @property
    def debugControl(self):
        return self.mapping.read_u16(0x4a)

    @debugControl.setter
    def debugControl(self, value):
        self.mapping.write_u16(0x4a, value)

    @property
    def debugControl2(self):
        return self.mapping.read_u16(0x4c)

    @debugControl2.setter
    def debugControl2(self, value):
        self.mapping.write_u16(0x4c, value)

    @property
    def debugFlags(self):
        return self.mapping.read_u16(0x4e)

    @property
    def debugStatus(self):
        return self.mapping.read_u16(0x50)

    @property
    def debugFTW1(self):
        return self.mapping.read_u32(0x52)

    @property
    def debugFTW2(self):
        return self.mapping.read_u32(0x56)

    @property
    def debugFTW1p(self):
        return self.mapping.read_u32(0x5a)

    @property
    def debugFTW2p(self):
        return self.mapping.read_u32(0x5e)

    @property
    def debugDDSData(self):
        return self.mapping.read_u32(0x62)

    @property
    def debugDDSRegSel(self):
        return self.mapping.read_u16(0x66)

    @property
    def debugFpSLFTW1(self):
        return self.mapping.read_u32(0x68)

    @debugFpSLFTW1.setter
    def debugFpSLFTW1(self, value):
        self.mapping.write_u32(0x68, value)

    @property
    def debugFpSLFTW1rb(self):
        return self.mapping.read_u32(0x6c)

    @property
    def acqBufSel(self):
        return self.mapping.read_u16(0x70)

    @acqBufSel.setter
    def acqBufSel(self, value):
        self.mapping.write_u16(0x70, value)

    @property
    def acqPageSel(self):
        return self.mapping.read_u16(0x72)

    @acqPageSel.setter
    def acqPageSel(self, value):
        self.mapping.write_u16(0x72, value)

    @property
    def acqFrzAddr(self):
        return self.mapping.read_u32(0x74)

    @property
    def acqSize(self):
        return self.mapping.read_u32(0x78)

    @property
    def acqStatus(self):
        return self.mapping.read_u16(0x7c)

    @property
    def acqControl(self):
        return self.mapping.read_u16(0x7e)

    @acqControl.setter
    def acqControl(self, value):
        self.mapping.write_u16(0x7e, value)

    @property
    def acqTrigSel(self):
        return self.mapping.read_u32(0x80)

    @acqTrigSel.setter
    def acqTrigSel(self, value):
        self.mapping.write_u32(0x80, value)

    @property
    def acqRateSel(self):
        return self.mapping.read_u16(0x84)

    @acqRateSel.setter
    def acqRateSel(self, value):
        self.mapping.write_u16(0x84, value)

    @property
    def acqMethod(self):
        return self.mapping.read_u16(0x86)

    @acqMethod.setter
    def acqMethod(self, value):
        self.mapping.write_u16(0x86, value)

    @property
    def serdCntrl(self):
        return self.mapping.read_u16(0x88)

    @serdCntrl.setter
    def serdCntrl(self, value):
        self.mapping.write_u16(0x88, value)

    @property
    def serdRXReg(self):
        return self.mapping.read_u16(0x8a)

    @property
    def serdPRBScnt(self):
        return self.mapping.read_u16(0x8c)

    @property
    def sysControl(self):
        return self.mapping.read_u16(0xe0)

    @sysControl.setter
    def sysControl(self, value):
        self.mapping.write_u16(0xe0, value)

    @property
    def hardwareVersion(self):
        return self.mapping.read_u16(0xe2)

    @property
    def designerID(self):
        return self.mapping.read_u16(0xe4)

    @property
    def boardTemp(self):
        return self.mapping.read_s16(0xe6)

    @property
    def testControl(self):
        return self.mapping.read_s16(0xe8)

    @testControl.setter
    def testControl(self, value):
        self.mapping.write_s16(0xe8, value)

    @property
    def testStatus(self):
        return self.mapping.read_s16(0xea)

    @property
    def firmwareVersion(self):
        return self.mapping.read_u32(0xf0)

    @property
    def serialNumber(self):
        return self.mapping.read_u64(0xf4)

    @property
    def memMapVersion(self):
        return self.mapping.read_u32(0xfc)


