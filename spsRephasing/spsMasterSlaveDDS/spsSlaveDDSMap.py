'''spsSlaveDDSMap Hardware Test Python module

Automatically generated by Topple 0.0.1
'''


__author__ = 'Miguel Ojeda'
__copyright__ = 'Copyright 2015, CERN BE'
__credits__ = ['Miguel Ojeda']
__license__ = 'Unknown'
__maintainer__ = 'Miguel Ojeda'
__email__ = 'mos@cern.ch'


import ctypes
import platform
import struct


class libvmebus(object):
    '''Minimal libvmebus Python binding (with only our needed bits)
    '''

    cpu = 'L865' if platform.machine() == 'i686' else 'L866'
    lib = ctypes.CDLL('/acc/local/%s/drv/vmebus/pyvmelib/libvmebus.so' % cpu)
    vme_map = lib.vme_map
    vme_map.restype = ctypes.c_void_p

    VME_A24_USER_DATA_SCT = 0x39
    VME_A32_USER_DATA_SCT = 0x09
    VME_D16 = 16
    VME_D32 = 32

    class vme_mapping(ctypes.Structure):
        _fields_ = [
	        ('window_num', ctypes.c_int),
	        ('*kernel_va', ctypes.c_void_p),
	        ('user_va', ctypes.c_void_p),
	        ('fd', ctypes.c_int),
	        ('window_enabled', ctypes.c_int),
	        ('data_width', ctypes.c_int),
	        ('am', ctypes.c_int),
	        ('read_prefetch_enabled', ctypes.c_int),
	        ('read_prefetch_size', ctypes.c_int),
	        ('v2esst_mode', ctypes.c_int),
	        ('bcast_select', ctypes.c_int),
	        ('pci_addru', ctypes.c_uint),
	        ('pci_addrl', ctypes.c_uint),
	        ('sizeu', ctypes.c_uint),
	        ('sizel', ctypes.c_uint),
	        ('vme_addru', ctypes.c_uint),
	        ('vme_addrl', ctypes.c_uint),
        ]


def interpret(value, typeString, swapped):
    '''Interpret raw input value as an signed/unsigned integer (according
    to the specified type) and possibly swapped as well (endianess change).
    '''

    unsignedFormatByTypeString = {
         'u8': 'B',
        'u16': 'H',
        'u32': 'L',
        'u64': 'Q',

         's8': 'B',
        's16': 'H',
        's32': 'L',
        's64': 'Q',
    }

    signed = typeString.startswith('s')

    inputByteOrder = '<'
    outputByteOrder = '<'
    inputFormat = unsignedFormatByTypeString[typeString]
    outputFormat = unsignedFormatByTypeString[typeString]

    if swapped:
        outputByteOrder = '>'
    if signed:
        outputFormat = outputFormat.lower()

    return struct.unpack(outputByteOrder + outputFormat, struct.pack(inputByteOrder + inputFormat, value))[0]


class VMEMapping(object):
    '''Minimal Python class to map the VME bus, based on pyvmelib/libvmebus
    '''

    _rawCtypeByTypeString = {
         'u8': ctypes.c_ubyte,
        'u16': ctypes.c_ushort,
        'u32': ctypes.c_uint,
        'u64': ctypes.c_ulonglong,

         's8': ctypes.c_ubyte,
        's16': ctypes.c_ushort,
        's32': ctypes.c_uint,
        's64': ctypes.c_ulonglong,
    }

    _ctypeByTypeString = {
         'u8': ctypes.c_ubyte,
        'u16': ctypes.c_ushort,
        'u32': ctypes.c_uint,
        'u64': ctypes.c_ulonglong,

         's8': ctypes.c_byte,
        's16': ctypes.c_short,
        's32': ctypes.c_int,
        's64': ctypes.c_longlong,
    }

    def __init__(self, addressModifier, dataWidth, baseAddress, size):
        vme_mapping = libvmebus.vme_mapping()
        vme_mapping.am                    = addressModifier
        vme_mapping.data_width            = dataWidth
        vme_mapping.vme_addru             = 0
        vme_mapping.vme_addrl             = baseAddress
        vme_mapping.sizeu                 = 0
        vme_mapping.sizel                 = size
        vme_mapping.read_prefetch_enabled = 0
        vme_mapping.bcast_select          = 0
        vme_mapping.window_num            = 0

        self.virtualAddress = libvmebus.vme_map(ctypes.byref(vme_mapping), 1)
        if self.virtualAddress is None:
            raise Exception('Error while mapping VME window')


    def pointer(self, offset, typeString):
        '''Returns an unsigned pointer to the specified offset
        '''

        return ctypes.cast(self.virtualAddress + offset, ctypes.POINTER(self._rawCtypeByTypeString[typeString]))


    def readList(self, offset, typeString, n):
        '''Reads a list of values at the specified offset
        '''

        address = self.pointer(offset, typeString)
        return [interpret(address[i], typeString, True) for i in range(n)]


    def writeList(self, offset, typeString, values):
        '''Writes a list of values at the specified offset
        '''

        # TODO: check values
        address = self.pointer(offset, typeString)
        for i in range(len(values)):
            address[i] = interpret(values[i], typeString, True)


    def read(self, offset, typeString):
        '''Reads a single register at the specified offset
        '''

        return self.readList(offset, typeString, 1)[0]


    def write(self, offset, typeString, value):
        '''Writes a single register at the specified offset
        '''

        self.writeList(offset, typeString, [value])


class Mode(object):
    '''VME modes for RF crates
    '''

    pass

class ModeA24D16(Mode):
    addressModifier = libvmebus.VME_A24_USER_DATA_SCT
    dataWidth = libvmebus.VME_D16

class ModeA32D32(Mode):
    addressModifier = libvmebus.VME_A32_USER_DATA_SCT
    dataWidth = libvmebus.VME_D32


defaultSize = 0x50000
defaultMode = ModeA24D16


def getModulesTransferRef():
    '''Get a dictionary of matching devices in the transfer.ref.

    The key of the map is the logical unit number (lun).

    TODO: parse the rest of the columns (e.g. second address window) as well
    '''

    moduleType = 'RF_SPS_SDDS'
    modules = {}
    with open('/etc/transfer.ref', 'rb') as fd:
        for line in fd.readlines():
            if '#+#' in line and moduleType in line:
                tokens = line.strip().split()

                if tokens[3] != 'VME':
                    raise Exception('Non-VME module found (should not happen?)')

                logicalUnitNumber = int(tokens[6])
                if logicalUnitNumber in modules:
                    raise Exception('Several matching modules with the same logical unit number (should not happen?)')

                dataPortSize = tokens[9]
                if not dataPortSize.startswith('DP'):
                    raise Exception('Unrecognized data port size')

                modules[logicalUnitNumber] = {
                    'logicalUnitNumber': logicalUnitNumber,
                    'addressModifier': tokens[8],
                    'dataWidth': int(dataPortSize[2:]),
                    'baseAddress': int(tokens[10], 16),
                    'size': int(tokens[11], 16),
                    'slot': int(tokens[19]) - 6,
                }

    return modules


class AcquisitionRegister(object):
    def __init__(self, offset, typeString):
        self.offset = offset
        self.typeString = typeString

    def __get__(self, instance, Class):
        return instance.mapping.read(self.offset, self.typeString)

    def __set__(self, instance, value):
        raise Exception('Acquisition registers are read-only')


class CommandRegister(object):
    def __init__(self, offset, typeString):
        self.offset = offset
        self.typeString = typeString

    def __get__(self, instance, Class):
        raise Exception('Command registers are write-only')

    def __set__(self, instance, value):
        instance.mapping.write(self.offset, self.typeString, value)


class SettingRegister(object):
    def __init__(self, offset, typeString):
        self.offset = offset
        self.typeString = typeString

    def __get__(self, instance, Class):
        return instance.mapping.read(self.offset, self.typeString)

    def __set__(self, instance, value):
        instance.mapping.write(self.offset, self.typeString, value)


class Module(object):
    '''Generated VME module abstraction
    '''

    @classmethod
    def slot(Class, slot_, size = defaultSize, mode = defaultMode):
        '''Returns a Module instance by slot number
        '''

        return Class(slot_ * 0x100000, size, mode)


    @classmethod
    def lun(Class, logicalUnitNumber = None):
        '''Returns a Module instance by the logical unit number (lun).

        The module has to be declared in the transfer.ref, i.e. CCDB.

        If no logical unit number is given, only one module must match
        (and it will be the one returned). Otherwise, it throws.
        '''

        modules = getModulesTransferRef()

        if len(modules) == 0:
            raise Exception('No matching module found in transfer.ref')

        if logicalUnitNumber is None:
            if len(modules) > 1:
                raise Exception('More than one matching module found in transfer.ref, but no logical unit number given')

            logicalUnitNumber = modules.keys()[0]

        if logicalUnitNumber not in modules:
            raise Exception('Logical number unit %s not in found matching modules: %s' % (logicalUnitNumber, modules.keys()))

        module = modules[logicalUnitNumber]

        # Assuming the address modifier is what we expect, i.e. just use
        # the data width to identify the mode
        mode = ModeA24D16 if module['dataWidth'] == 16 else ModeA32D32

        return Class(module['baseAddress'], module['size'], mode)


    def __init__(self, baseAddress, size = 0x100000, mode = ModeA24D16):
        self.mapping = VMEMapping(
            mode.addressModifier,
            mode.dataWidth,
            baseAddress,
            size
        )



    control1        =     SettingRegister( 0x0, 'u16')
    vmeIRQStatID    =     SettingRegister( 0x2, 'u16')
    vmeIRQLevel     =     SettingRegister( 0x4, 'u16')
    status1         = AcquisitionRegister( 0x6, 'u16')
    ident           = AcquisitionRegister( 0x8, 'u16')
    control2        =     SettingRegister( 0xa, 'u16')
    control3        =     SettingRegister( 0xc, 'u16')
    rfOnOffset      =     SettingRegister(0x20, 'u16')
    rfOffOffset     =     SettingRegister(0x22, 'u16')
    minDFTW1        =     SettingRegister(0x24, 'u32')
    maxDFTW1        =     SettingRegister(0x28, 'u32')
    minFTW1         =     SettingRegister(0x2c, 'u32')
    maxFTW1         =     SettingRegister(0x30, 'u32')
    frevPhaseOffset =     SettingRegister(0x34, 'u16')
    faults          = AcquisitionRegister(0x36, 'u16')
    ddsData         =     SettingRegister(0x40, 'u32')
    ddsRegSel       =     SettingRegister(0x44, 'u16')
    ddsControl      =     SettingRegister(0x46, 'u16')
    ddsControl2     =     SettingRegister(0x48, 'u16')
    debugControl    =     SettingRegister(0x4a, 'u16')
    debugControl2   =     SettingRegister(0x4c, 'u16')
    debugFlags      = AcquisitionRegister(0x4e, 'u16')
    debugStatus     = AcquisitionRegister(0x50, 'u16')
    debugFTW1       = AcquisitionRegister(0x52, 'u32')
    debugFTW2       = AcquisitionRegister(0x56, 'u32')
    debugFTW1p      = AcquisitionRegister(0x5a, 'u32')
    debugFTW2p      = AcquisitionRegister(0x5e, 'u32')
    debugDDSData    = AcquisitionRegister(0x62, 'u32')
    debugDDSRegSel  = AcquisitionRegister(0x66, 'u16')
    debugFpSLFTW1   =     SettingRegister(0x68, 'u32')
    debugFpSLFTW1rb = AcquisitionRegister(0x6c, 'u32')
    acqBufSel       =     SettingRegister(0x70, 'u16')
    acqPageSel      =     SettingRegister(0x72, 'u16')
    acqFrzAddr      = AcquisitionRegister(0x74, 'u32')
    acqSize         = AcquisitionRegister(0x78, 'u32')
    acqStatus       = AcquisitionRegister(0x7c, 'u16')
    acqControl      =     SettingRegister(0x7e, 'u16')
    acqTrigSel      =     SettingRegister(0x80, 'u32')
    acqRateSel      =     SettingRegister(0x84, 'u16')
    acqMethod       =     SettingRegister(0x86, 'u16')
    serdCntrl       =     SettingRegister(0x88, 'u16')
    serdRXReg       = AcquisitionRegister(0x8a, 'u16')
    serdPRBScnt     = AcquisitionRegister(0x8c, 'u16')
    sysControl      =     SettingRegister(0xe0, 'u16')
    hardwareVersion = AcquisitionRegister(0xe2, 'u16')
    designerID      = AcquisitionRegister(0xe4, 'u16')
    boardTemp       = AcquisitionRegister(0xe6, 's16')
    testControl     =     SettingRegister(0xe8, 's16')
    testStatus      = AcquisitionRegister(0xea, 's16')
    firmwareVersion = AcquisitionRegister(0xf0, 'u32')
    serialNumber    = AcquisitionRegister(0xf4, 'u64')
    memMapVersion   = AcquisitionRegister(0xfc, 'u32')

